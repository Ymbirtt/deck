{"version":3,"sources":["day8/re_frame_10x/panels/subs/subs.cljs"],"mappings":"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","names":["day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.reg_sub","p__46377","map__46378","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","subs","_","traces","cljs.core.filter","day8.re-frame-10x.tools.metamorphic/subscription?","p__46381","map__46382","subscription-info","p__46385","map__46386","sub-state","p__46390","map__46391","day8.re-frame-10x.panels.subs.subs/sub-type->value","sub-type","G__46394","cljs.core/Keyword","day8.re-frame-10x.panels.subs.subs/accumulate-sub-value","order","exp","total","temp__5733__auto__","cljs.core/first","js/Math.pow","cljs.core/rest","day8.re-frame-10x.panels.subs.subs/accumulate-sub-value-memoized","cljs.core/memoize","day8.re-frame-10x.panels.subs.subs/sub-sort-val","order-x","order-y","cljs.core/compare","day8.re-frame-10x.panels.subs.subs/sub-op-type->type","t","G__46399","p__46400","p__46401","vec__46402","cljs.core.nth","vec__46405","day8.re-frame-10x.panels.subs.subs/prepare-pod-info","sub-info","subscription","remove-fn","cljs.core._EQ_","me","cljs.core/val","cljs.core/constantly","subx","cljs.core.remove","cljs.core.map","state","sub","cljs.core/key","cljs.core.get_in","cljs.core.pr_str","or__4126__auto__","cljs.core/contains?","cljs.core.assoc","cljs.core.sort_by","p__46412","map__46413","pre-epoch-state","p__46418","map__46419","reaction-state","p__46421","map__46422","filter-str","p__46427","vec__46428","all-subs","ignore-unchanged-l2?","pins","compare-fn","s1","s2","p1","cljs.core/boolean","p2","G__46431","cljs.core.sort","day8.re-frame-10x.tools.metamorphic/unchanged-l2-subscription?","cljs.core/not-empty","p__46435","map__46436","path","id","clojure.string/includes?","cljs.core.mapcat","cljs.core/frequencies","counts","cljs.core/count","p__46445","map__46446","expansions","p__46449","map__46450","pinned"],"sourcesContent":["(ns day8.re-frame-10x.panels.subs.subs\n  (:require\n    [day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core :as rf]\n    [day8.re-frame-10x.navigation.epochs.subs :as epochs.subs]\n    [day8.re-frame-10x.panels.traces.subs :as traces.subs]\n    [day8.re-frame-10x.tools.metamorphic :as metam]\n    [clojure.string :as string]))\n\n(rf/reg-sub\n  ::root\n  (fn [{:keys [subs]} _]\n    subs))\n\n(rf/reg-sub\n  ::all-sub-traces\n  :<- [::traces.subs/filtered-by-epoch-always]\n  (fn [traces]\n    (filter metam/subscription? traces)))\n\n(rf/reg-sub\n  ::subscription-info\n  :<- [::epochs.subs/root]\n  (fn [{:keys [subscription-info]} _]\n    subscription-info))\n\n(rf/reg-sub\n  ::sub-state\n  :<- [::epochs.subs/root]\n  (fn [{:keys [sub-state]} _]\n    sub-state))\n\n(rf/reg-sub\n  ::current-epoch-sub-state\n  :<- [::epochs.subs/selected-match-state]\n  (fn [{:keys [sub-state]} _]\n    sub-state))\n\n(defn sub-type->value\n  [sub-type]\n  (case sub-type\n    :sub/create  5\n    :sub/run     4\n    :sub/dispose 3\n    :sub/not-run 2\n                 1))\n\n(defn accumulate-sub-value\n  \"Calculate a sorting value for a series of subscription trace types.\"\n  ;; A reader might reasonably ask, \"Why are we going to all this work here?\"\n  ;; We calculate a custom value rather than just comparing two order vectors,\n  ;; because the default compare logic for comparing vectors is to sort shorter\n  ;; vectors above longer ones, whereas we want all CRR, CR, C orders to be\n  ;; sorted adjacent to each other, in that order.\n  ;;\n  ;; The first sub type in the order is worth (n * 10^3),\n  ;; then the next one (if it exists), is worth (n * 10^2), and so-on.\n  [order]\n  (loop [exp   3\n         total 0\n         order order]\n    (if-let [sub-type (first order)]\n      (recur (dec exp)\n             (+ total (* (sub-type->value sub-type) (js/Math.pow 10 exp)))\n             (rest order))\n      total)))\n\n(def accumulate-sub-value-memoized\n  (memoize accumulate-sub-value))\n\n(defn sub-sort-val [order-x order-y]\n  ;; Note x and y are reversed here so that the \"highest\" sub orders get sorted first.\n  (compare (accumulate-sub-value-memoized order-y)\n           (accumulate-sub-value-memoized order-x)))\n\n(defn sub-op-type->type [t]\n  (case (:op-type t)\n    :sub/create :created\n    :sub/run :re-run\n    :sub/dispose :destroyed\n\n    :not-run))\n\n(defn prepare-pod-info\n  \"Returns sub info prepared for rendering in pods\"\n  [[sub-info sub-state] [subscription]]\n  (let [remove-fn (if (= subscription ::intra-epoch-subs)\n                    (fn [me] (nil? (:order (val me))))\n                    (constantly false))\n        subx      (->> sub-state\n                       (remove remove-fn)\n                       (map (fn [me] (let [state        (val me)\n                                           subscription (:subscription state)\n                                           sub          {:id         (key me)\n                                                         :reagent-id (key me)\n                                                         :layer      (get-in sub-info [(first subscription) :layer])\n                                                         :path-data  subscription\n                                                         :path       (pr-str subscription)\n                                                         :order      (or (:order state) [:sub/not-run])\n                                                         :sub/traits (:sub/traits state)}\n                                           sub          (if (contains? state :value)\n                                                          (assoc sub :value (:value state))\n                                                          sub)\n                                           sub          (if (contains? state :previous-value)\n                                                          (assoc sub :previous-value (:previous-value state))\n                                                          sub)]\n                                       sub)))\n                       (sort-by :order sub-sort-val)        ;; Also sort by subscription-id\n                       #_(sort-by :path))]\n    subx))\n\n(rf/reg-sub\n  ::pre-epoch-state\n  :<- [::current-epoch-sub-state]\n  (fn [{:keys [pre-epoch-state]} _]\n    pre-epoch-state))\n\n(rf/reg-sub\n  ::reaction-state\n  :<- [::current-epoch-sub-state]\n  (fn [{:keys [reaction-state]} _]\n    reaction-state))\n\n(rf/reg-sub\n  ::intra-epoch-subs\n  :<- [::subscription-info]\n  :<- [::pre-epoch-state]\n  prepare-pod-info)\n\n(rf/reg-sub\n  ::all-subs\n  :<- [::subscription-info]\n  :<- [::reaction-state]\n  prepare-pod-info)\n\n(rf/reg-sub\n  ::filter-str\n  :<- [::root]\n  (fn [{:keys [filter-str]} _]\n    filter-str))\n\n(rf/reg-sub\n  ::visible-subs\n  :<- [::all-subs]\n  :<- [::ignore-unchanged-l2-subs?]\n  :<- [::filter-str]\n  :<- [::sub-pins]\n  (fn [[all-subs ignore-unchanged-l2? filter-str pins]]\n    (let [compare-fn (fn [s1 s2]\n                       (let [p1 (boolean (get-in pins [(:id s1) :pin?]))\n                             p2 (boolean (get-in pins [(:id s2) :pin?]))]\n                         (if (= p1 p2)\n                           (compare (:path s1) (:path s2))\n                           p1)))]\n      (cond->> (sort compare-fn all-subs)\n               ignore-unchanged-l2? (remove metam/unchanged-l2-subscription?)\n               (not-empty filter-str) (filter (fn [{:keys [path id]}]\n                                                (or (string/includes? path filter-str)\n                                                    (get-in pins [id :pin?]))))))))\n\n(rf/reg-sub\n  ::sub-counts\n  :<- [::visible-subs]\n  (fn [subs _]\n    (->> subs\n         (mapcat :order)\n         (frequencies))))\n\n(rf/reg-sub\n  ::created-count\n  :<- [::sub-counts]\n  (fn [counts]\n    (get counts :sub/create 0)))\n\n(rf/reg-sub\n  ::re-run-count\n  :<- [::sub-counts]\n  (fn [counts]\n    (get counts :sub/run 0)))\n\n(rf/reg-sub\n  ::destroyed-count\n  :<- [::sub-counts]\n  (fn [counts]\n    (get counts :sub/dispose 0)))\n\n(rf/reg-sub\n  ::not-run-count\n  :<- [::sub-counts]\n  (fn [counts]\n    (get counts :sub/not-run 0)))\n\n(rf/reg-sub\n  ::unchanged-l2-subs-count\n  :<- [::all-subs]\n  (fn [subs]\n    (count (filter metam/unchanged-l2-subscription? subs))))\n\n(rf/reg-sub\n  ::ignore-unchanged-l2-subs?\n  :<- [::root]\n  (fn [subs _]\n    (:ignore-unchanged-subs? subs true)))\n\n(rf/reg-sub\n  ::sub-expansions\n  :<- [::root]\n  (fn [{:keys [expansions]} _]\n    expansions))\n\n(rf/reg-sub\n  ::sub-pins\n  :<- [::root]\n  (fn [{:keys [pinned]} _]\n    pinned))\n"]}