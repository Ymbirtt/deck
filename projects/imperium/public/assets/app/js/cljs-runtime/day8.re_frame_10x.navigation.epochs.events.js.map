{"version":3,"sources":["day8/re_frame_10x/navigation/epochs/events.cljs"],"mappings":"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","names":["day8.re-frame-10x.navigation.epochs.events/log-trace?","trace","render-operation?","cljs.core._EQ_","component-name","cljs.core.get_in","clojure.string/includes?","day8.re-frame-10x.navigation.epochs.events/first-match-id","m","cljs.core/first","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.reg_event_fx","day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core/trim-v","p__45384","p__45385","map__45386","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","vec__45387","cljs.core.nth","db","new-traces","temp__5733__auto__","filtered-traces","cljs.core.filter","cljs.core.sort_by","map__45393","number-of-epochs-to-retain","events-to-ignore","cljs.core/vals","cljs.core.map","cljs.core/set","previous-traces","parse-state","day8.re-frame-10x.tools.metamorphic/initial-parse-state","drop-re-frame","drop-reagent","all-traces","cljs.core.reduce","cljs.core/conj","day8.re-frame-10x.tools.metamorphic/parse-traces","new-matches","previous-matches","cljs.core.assoc","cljs.core.remove","match","event","day8.re-frame-10x.tools.metamorphic/matched-event","cljs.core/contains?","subscription-info","day8.re-frame-10x.tools.metamorphic/subscription-info","sub-state","day8.re-frame-10x.tools.metamorphic/initial-sub-state","subscription-match-state","day8.re-frame-10x.tools.metamorphic/subscription-match-state","subscription-matches","cljs.core/rest","new-sub-state","cljs.core/last","timing","cljs.core.mapv","epoch-traces","cljs.core.into","cljs.core.comp","day8.re-frame-10x.tools.coll/id-between-xf","start-of-epoch","event-handler-trace","day8.re-frame-10x.tools.metamorphic/event-handler?","dofx-trace","day8.re-frame-10x.tools.metamorphic/event-dofx?","event-trace","day8.re-frame-10x.tools.metamorphic/event-run?","finish-run","or__4126__auto__","day8.re-frame-10x.tools.metamorphic/finish-run?","day8.re-frame-10x.tools.coll/last-in-vec","day8.re-frame-10x.tools.metamorphic/elapsed-time","sub-match","t","quiescent?","cljs.core/seq","day8.re-frame-10x.tools.metamorphic/quiescent?","all-matches","retained-matches","cljs.core/take-last","first-id-to-retain","retained-traces","p1__45383#","cljs.core.drop_while","day8.re-frame-10x.tools.metamorphic/low-level-reagent-trace?","day8.re-frame-10x.tools.metamorphic/low-level-re-frame-trace?","cljs.core/assoc-in","cljs.core.update","epochs","selected-index","selected-id","cljs.core.juxt","cljs.core/identity","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.path","p__45411","map__45412","_","temp__5737__auto__","match-ids","match-array-index","day8.re-frame-10x.tools.coll/find-index-in-vec","x","new-id","cljs.core/count","p__45416","map__45417","p__45422","map__45423","p__45425","p__45426","map__45427","vec__45428","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.reg_event_db","selected-epoch-id","app-db-before","day8.re-frame-10x.tools.metamorphic/app-db-before","cljs.core/reset!","re-frame.db/app-db","event-to-replay","re-frame.core/dispatch","cljs.core.dissoc","re-frame.trace/reset-tracing!","p__45435","vec__45436","match-id","temp__5739__auto__","new-db","day8.re-frame-10x.tools.metamorphic/app-db-after"],"sourcesContent":["(ns day8.re-frame-10x.navigation.epochs.events\n  (:require\n    [clojure.string                                               :as string]\n    [re-frame.core]\n    [re-frame.db]\n    [re-frame.trace]\n    [day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core :as rf]\n    [day8.re-frame-10x.tools.metamorphic                          :as metam]\n    [day8.re-frame-10x.tools.coll                                 :as tools.coll]))\n\n(defn log-trace? [trace]\n  (let [render-operation? (or (= (:op-type trace) :render)\n                              (= (:op-type trace) :componentWillUnmount))\n        component-name    (get-in trace [:tags :component-name] \"\")]\n    (if-not render-operation?\n      true\n      (not\n        (and\n          (string? component-name)\n          (string/includes? component-name \"devtools outer\"))))))\n\n(defn first-match-id\n  [m]\n  (-> m :match-info first :id))\n\n(rf/reg-event-fx\n  ::receive-new-traces\n  [rf/trim-v]\n  (fn [{:keys [db]} [new-traces]]\n    (if-let [filtered-traces (->> (filter log-trace? new-traces)\n                                  (sort-by :id))]\n      (let [number-of-epochs-to-retain (get-in db [:settings :number-of-epochs])\n            events-to-ignore           (->> (get-in db [:settings :ignored-events]) vals (map :event-id) set)\n            previous-traces            (get-in db [:traces :all] [])\n            parse-state                (get-in db [:epochs :parse-state] metam/initial-parse-state)\n            {drop-re-frame :re-frame drop-reagent :reagent} (get-in db [:settings :low-level-trace])\n            all-traces                 (reduce conj previous-traces filtered-traces)\n            parse-state                (metam/parse-traces parse-state filtered-traces)\n            ;; TODO:!!!!!!!!!!!!! We should be parsing everything else with the traces that span the newly matched\n            ;; epochs, not the filtered-traces, as these are only partial.\n            new-matches                (:partitions parse-state)\n            previous-matches           (get-in db [:epochs :matches] [])\n            parse-state                (assoc parse-state :partitions []) ;; Remove matches we know about\n            new-matches                (remove (fn [match]\n                                                 (let [event (get-in (metam/matched-event match) [:tags :event])]\n                                                   (contains? events-to-ignore (first event)))) new-matches)\n            ;; subscription-info is calculated separately from subscription-match-state because they serve different purposes:\n            ;; - subscription-info collects all the data that we know about the subscription itself, like its layer, inputs and other\n            ;;   things that are defined as part of the reg-sub.\n            ;; - subscription-match-state collects all the data that we know about the state of specific instances of subscriptions\n            ;;   like its reagent id, when it was created, run, disposed, what values it returned, e.t.c.\n            subscription-info          (metam/subscription-info (get-in db [:epochs :subscription-info] {}) filtered-traces (get-in db [:app-db :reagent-id]))\n            sub-state                  (get-in db [:epochs :sub-state] metam/initial-sub-state)\n            subscription-match-state   (metam/subscription-match-state sub-state all-traces new-matches)\n            subscription-matches       (rest subscription-match-state)\n\n            new-sub-state              (last subscription-match-state)\n            timing                     (mapv (fn [match]\n                                               (let [epoch-traces        (into []\n                                                                               (comp\n                                                                                 (tools.coll/id-between-xf (:id (first match)) (:id (last match))))\n                                                                               all-traces)\n                                                     ;; TODO: handle case when there are no epoch-traces\n                                                     start-of-epoch      (nth epoch-traces 0)\n                                                     ;; TODO: optimise trace searching\n                                                     event-handler-trace (first (filter metam/event-handler? epoch-traces))\n                                                     dofx-trace          (first (filter metam/event-dofx? epoch-traces))\n                                                     event-trace         (first (filter metam/event-run? epoch-traces))\n                                                     finish-run          (or (first (filter metam/finish-run? epoch-traces))\n                                                                             (tools.coll/last-in-vec epoch-traces))]\n                                                 {:re-frame/event-run-time     (metam/elapsed-time start-of-epoch finish-run)\n                                                  :re-frame/event-time         (:duration event-trace)\n                                                  :re-frame/event-handler-time (:duration event-handler-trace)\n                                                  :re-frame/event-dofx-time    (:duration dofx-trace)}))\n                                             new-matches)\n\n            new-matches                (map (fn [match sub-match t] {:match-info match\n                                                                     :sub-state  sub-match\n                                                                     :timing     t})\n                                            new-matches subscription-matches timing)\n            ;; If there are new matches found, then by definition, a quiescent trace must have been received\n            ;; However in cases where we reset the db in a replay, we won't get an event match.\n            ;; We short circuit here to avoid iterating over the traces when it's unnecessary.\n            quiescent?                 (or (seq new-matches)\n                                           (filter metam/quiescent? filtered-traces))\n            all-matches                (reduce conj previous-matches new-matches)\n            retained-matches           (into [] (take-last number-of-epochs-to-retain all-matches))\n            first-id-to-retain         (first-match-id (first retained-matches))\n            retained-traces            (into [] (comp (drop-while #(< (:id %) first-id-to-retain))\n                                                      (remove (fn [trace]\n                                                                (or (when drop-reagent (metam/low-level-reagent-trace? trace))\n                                                                    (when drop-re-frame (metam/low-level-re-frame-trace? trace)))))) all-traces)]\n        {:db       (-> db\n                       (assoc-in [:traces :all] retained-traces)\n                       (update :epochs (fn [epochs]\n                                         (let [selected-index (:selected-epoch-index epochs)\n                                               selected-id    (:selected-epoch-id epochs)]\n                                           (assoc epochs\n                                             :matches retained-matches\n                                             :matches-by-id (into {} (map (juxt first-match-id identity)) retained-matches)\n                                             :match-ids (mapv first-match-id retained-matches)\n                                             :parse-state parse-state\n                                             :sub-state new-sub-state\n                                             :subscription-info subscription-info\n                                             ;; Reset selected epoch to the head of the list if we got a new event in.\n                                             :selected-epoch-id (if (seq new-matches) (first-match-id (last retained-matches)) selected-id)\n                                             :selected-epoch-index (if (seq new-matches) nil selected-index))))))\n         :dispatch (when quiescent? [::quiescent])})\n      ;; Else\n      {:db db})))\n\n;; TODO: this code is a bit messy, needs refactoring and cleaning up.\n(rf/reg-event-fx\n  ::previous\n  [(rf/path [:epochs])]\n  (fn [{:keys [db]} _]\n    (if-some [selected-id (:selected-epoch-id db)]\n      (let [match-ids         (:match-ids db)\n            match-array-index (tools.coll/find-index-in-vec (fn [x] (= selected-id x)) match-ids)\n            new-id            (nth match-ids (dec match-array-index))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]})\n      (let [new-id (nth (:match-ids db)\n                        (- (count (:match-ids db)) 2))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]}))))\n\n\n(rf/reg-event-fx\n  ::next\n  [(rf/path [:epochs])]\n  (fn [{:keys [db]} _]\n    (if-some [selected-id (:selected-epoch-id db)]\n      (let [match-ids         (:match-ids db)\n            match-array-index (tools.coll/find-index-in-vec (fn [x] (= selected-id x)) match-ids)\n            new-id            (nth match-ids (inc match-array-index))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]})\n      (let [new-id (tools.coll/last-in-vec (:match-ids db))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]}))))\n\n(rf/reg-event-fx\n  ::most-recent\n  [(rf/path [:epochs])]\n  (fn [{:keys [db]} _]\n    (let [new-id (tools.coll/last-in-vec (:match-ids db))]\n      {:db       (assoc db :selected-epoch-index nil\n                           :selected-epoch-id new-id)\n       :dispatch [::reset-current-epoch-app-db new-id]})))\n\n(rf/reg-event-fx\n  ::load\n  [(rf/path [:epochs]) rf/trim-v]\n  (fn [{:keys [db]} [new-id]]\n    {:db       (assoc db :selected-epoch-id new-id)\n     :dispatch [::reset-current-epoch-app-db new-id]}))\n\n(rf/reg-event-db\n  ::replay\n  [(rf/path [:epochs])]\n  (fn [epochs _]\n    (let [selected-epoch-id (or (get epochs :selected-epoch-id)\n                                (tools.coll/last-in-vec (get epochs :match-ids)))\n          event-trace      (-> (get-in epochs [:matches-by-id selected-epoch-id :match-info])\n                               (metam/matched-event))\n          app-db-before    (metam/app-db-before event-trace)\n          event            (get-in event-trace [:tags :event])]\n      (reset! re-frame.db/app-db app-db-before)\n      ;; Wait for quiescence\n      (assoc epochs :replay event))))\n\n(rf/reg-event-db\n  ::quiescent\n  [(rf/path [:epochs])]\n  (fn [db _]\n    (if-some [event-to-replay (:replay db)]\n      (do (re-frame.core/dispatch event-to-replay)\n          (dissoc db :replay))\n      db)))\n\n(rf/reg-event-db\n  ::reset\n  (fn [db]\n    (re-frame.trace/reset-tracing!)\n    (dissoc db :epochs :traces)))\n\n(rf/reg-event-db\n  ::reset-current-epoch-app-db\n  [rf/trim-v]\n  (fn [db [new-id]]\n    (when (get-in db [:settings :app-db-follows-events?])\n      (let [epochs   (:epochs db)\n            match-id (or new-id\n                         ;; new-id may be nil when we call this event from :settings/play\n                         (tools.coll/last-in-vec (get epochs :match-ids)))\n            match    (get-in epochs [:matches-by-id match-id])\n            event    (metam/matched-event (:match-info match))]\n        ;; Don't mess up the users app if there is a problem getting app-db-after.\n        (when-some [new-db (metam/app-db-after event)]\n          (reset! re-frame.db/app-db new-db))))\n    db))"]}