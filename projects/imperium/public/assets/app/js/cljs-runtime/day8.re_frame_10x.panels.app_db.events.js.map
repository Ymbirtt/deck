{"version":3,"sources":["day8/re_frame_10x/panels/app_db/events.cljs"],"mappings":"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","names":["day8.re-frame-10x.panels.app-db.events/paths-interceptors","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.path","day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core/trim-v","day8.re_frame_10x.fx.local_storage.after","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.reg_event_db","paths","_","cljs.core.assoc","js/Date.now","p__47307","vec__47308","cljs.core.nth","path-id","path-str","path","day8.re-frame-10x.tools.reader.edn/read-string-maybe","cljs.core/assoc-in","cljs.core/sequential?","clojure.string/blank?","p__47312","vec__47313","map__47316","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","valid-path?","cljs.core.pr_str","p__47324","vec__47325","open?","p__47329","vec__47330","diff?","cljs.core.get_in","p__47333","vec__47334","cljs.core.dissoc","p__47337","vec__47338","p__47341","vec__47342","search-string","p__47351","vec__47352","p__47355","vec__47356","cljs.core/contains?","cljs.core.disj","cljs.core.conj","re-frame.interop/reagent-id","re-frame.db/app-db"],"sourcesContent":["(ns day8.re-frame-10x.panels.app-db.events\n  (:require\n    [day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core :as rf]\n    [day8.re-frame-10x.fx.local-storage :as local-storage]\n    [clojure.string :as string]\n    [day8.re-frame-10x.tools.reader.edn :as reader.edn]))\n\n(def paths-interceptors\n  [(rf/path [:app-db :paths])\n   rf/trim-v\n   (local-storage/after \"app-db-paths\")])\n\n;; The core idea with :app-db/update-path and :app-db/update-path-blur\n;; is that we need to separate the users text input (`path-str`) with the\n;; parsing of that string (`path`). We let the user type any string that\n;; they like, and check it for validity on each change. If it is valid\n;; then we update `path` and mark the pod as valid. If it isn't valid then\n;; we don't update `path` and mark the pod as invalid.\n;;\n;; On blur of the input, we reset path-str to the last valid path, if\n;; the pod isn't currently valid.\n\n(rf/reg-event-db\n  ::create-path\n  paths-interceptors\n  (fn [paths _]\n    (assoc paths\n      (js/Date.now)\n      {:diff?       false\n       :open?       true\n       :path        nil\n       :path-str    \"\"\n       :valid-path? true})))\n\n(rf/reg-event-db\n  ::update-path\n  paths-interceptors\n  (fn [paths [path-id path-str]]\n    (let [path  (reader.edn/read-string-maybe path-str)\n          paths (assoc-in paths [path-id :path-str] path-str)]\n      (if (or (and (some? path)\n                   (sequential? path))\n              (string/blank? path-str))\n        (-> paths\n            (assoc-in [path-id :path] path)\n            (assoc-in [path-id :valid-path?] true))\n        (assoc-in paths [path-id :valid-path?] false)))))\n\n\n(rf/reg-event-db\n  ::update-path-blur\n  paths-interceptors\n  (fn [paths [path-id]]\n    (let [{:keys [valid-path? path]} (get paths path-id)]\n      (if valid-path?\n        paths\n        (-> (assoc-in paths [path-id :path-str] (pr-str path))\n            (assoc-in [path-id :valid-path?] true))))))\n\n(rf/reg-event-db\n  ::set-path-visibility\n  paths-interceptors\n  (fn [paths [path-id open?]]\n    (assoc-in paths [path-id :open?] open?)))\n\n(rf/reg-event-db\n  ::set-diff-visibility\n  paths-interceptors\n  (fn [paths [path-id diff?]]\n    (let [open? (if diff?\n                  true\n                  (get-in paths [path-id :open?]))]\n      (-> paths\n          (assoc-in [path-id :diff?] diff?)\n          ;; If we turn on diffing then we want to also expand the path\n          (assoc-in [path-id :open?] open?)))))\n\n(rf/reg-event-db\n  ::remove-path\n  paths-interceptors\n  (fn [paths [path-id]]\n    (dissoc paths path-id)))\n\n(rf/reg-event-db\n  ::paths\n  paths-interceptors\n  (fn [_ [paths]]\n    paths))\n\n;; [IJ] TODO: This doesn't appear to be used anywhere:\n(rf/reg-event-db\n  ::set-search-string\n  [(rf/path [:app-db :search-string]) rf/trim-v]\n  (fn [_ [search-string]]\n    search-string))\n\n(rf/reg-event-db\n  ::set-json-ml-paths\n  [(rf/path [:app-db :json-ml-expansions]) rf/trim-v (local-storage/after \"app-db-json-ml-expansions\")]\n  (fn [_ [paths]]\n    paths))\n\n(rf/reg-event-db\n  ::toggle-expansion\n  [(rf/path [:app-db :json-ml-expansions]) rf/trim-v (local-storage/after \"app-db-json-ml-expansions\")]\n  (fn [paths [path]]\n    (if (contains? paths path)\n      (disj paths path)\n      (conj paths path))))\n\n(rf/reg-event-db\n  ::reagent-id\n  [(rf/path [:app-db :reagent-id])]\n  (fn [_ _]\n    (re-frame.interop/reagent-id re-frame.db/app-db)))\n\n"]}